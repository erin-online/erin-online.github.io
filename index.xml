<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>im just vibing. im chilling and vibing on the internet</title><link>https://erin-online.github.io/</link><description>Recent content on im just vibing. im chilling and vibing on the internet</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Wed, 03 Aug 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://erin-online.github.io/index.xml" rel="self" type="application/rss+xml"/><item><title>Know Your Enemy</title><link>https://erin-online.github.io/writings/know_your_enemy/</link><pubDate>Wed, 03 Aug 2022 00:00:00 +0000</pubDate><guid>https://erin-online.github.io/writings/know_your_enemy/</guid><description>Mini Progress Update Before I get into the post for today, I want to share how things have been going since the conclusion of my first project:
I&amp;rsquo;ve been working with Common Lisp and it&amp;rsquo;s been good to me so far. When I said I wanted a language that encouraged me to get groundwork in place, my only frame of reference was object-oriented stuff like Java. I still think OOP is neat, but Lisp&amp;rsquo;s interactive REPL is great as well to help me work through bugs.</description><content>&lt;h2 id="mini-progress-update">Mini Progress Update&lt;/h2>
&lt;p>Before I get into the post for today, I want to share how things have been going since the conclusion of my first project:&lt;/p>
&lt;ul>
&lt;li>I&amp;rsquo;ve been working with Common Lisp and it&amp;rsquo;s been good to me so far. When I said I wanted a language that encouraged me to get groundwork in place, my only frame of reference was object-oriented stuff like Java. I still think OOP is neat, but Lisp&amp;rsquo;s interactive REPL is great as well to help me work through bugs. The syntax is also really easy to understand. My code is actually readable this time so I&amp;rsquo;ll be linking the GitHub repository in the project writeup.&lt;/li>
&lt;li>I&amp;rsquo;m implementing a basic neural network which is almost done. (This is not the main part of the project, which will come later.) Motivation has dried up a bit recently, I have to take care of myself better. No major obstacles other than getting this version of Emacs to stop autocompleting my parentheses and maybe implementing some basic graphics so I can see what&amp;rsquo;s going on, like the graphs in the last project.&lt;/li>
&lt;li>A couple friends recommended Arch Linux to me so I installed that, but it&amp;rsquo;s just been a barrage of googling error message after error message to move forward so far. (Currently I have it installed, but need to install a network package so I can connect to the Internet and install other packages.) I&amp;rsquo;m gonna stay on Windows for now and will maybe press onward in the future, idk.&lt;/li>
&lt;/ul>
&lt;h2 id="problems-with-the-chess-community">Problems with the Chess Community&lt;/h2>
&lt;p>Most people I know are familiar with the disdain I have for my local chess scene. The reason for this is that most of the people in it feel uninterested in using chess to make friends or get to know people better. It ends up in an intensely casual game with no passion involved, so the unique playstyle and vision of the game both players have ultimately receives no attention. This isolation is especially hurtful in my case; as a trans woman I almost never get gendered correctly at the chess club. This is in stark contrast to other competitive communities I notice.&lt;/p>
&lt;p>This lack of interest in using chess to understand things seems to extend into the world of computer chess. Engines such as Stockfish, Leela Chess Zero (Lc0), and Komodo are unimaginably strong compared to even the best humans. It seems completely ridiculous that no new understandings can be drawn from this mastery of this incredibly complex game, but that&amp;rsquo;s exactly what has happened. Two things have changed at the human level in computer chess: grandmasters have gotten better at opening preparation, and random Twitch chat spectators have suddenly become geniuses now that they can see the computer evaluation of important games in real time.&lt;/p>
&lt;p>A more seasoned community member might disagree with me and provide other examples, but my point is that there is still much more to be done.&lt;/p>
&lt;h2 id="generalization">Generalization&lt;/h2>
&lt;p>Consider the following game:&lt;/p>
&lt;ul>
&lt;li>There are two players, Player A and Player B.&lt;/li>
&lt;li>Player A can choose to press a red button or a green button.&lt;/li>
&lt;li>If Player A presses the red button, Player B must play through a level of Crash Bandicoot without losing a life.&lt;/li>
&lt;li>If Player A presses the green button, Player B must play through a level of Touhou without losing a life.&lt;/li>
&lt;li>If Player B succeeds, they win. If they fail, Player A wins.&lt;/li>
&lt;/ul>
&lt;p>Now, if we want to optimize this game using neural networks, it doesn&amp;rsquo;t make a whole lot of sense to use one network for the whole thing. Don&amp;rsquo;t get me wrong, generalized networks are really cool, but making one isn&amp;rsquo;t as simple as telling a network to do two unrelated things. There are two main things to consider:&lt;/p>
&lt;ul>
&lt;li>The network must be reasonably powerful. (Larger number of nodes, good amount of training)&lt;/li>
&lt;li>There must be some sort of &amp;ldquo;thread&amp;rdquo; connecting the different tasks.&lt;/li>
&lt;/ul>
&lt;p>For a counterexample, consider the following two chess positions:&lt;/p>
&lt;p>&lt;img src="img1_chess_endgame.png" alt="A chess endgame">&lt;/p>
&lt;p>&lt;img src="img2_chess_midgame.png" alt="A chess midgame">&lt;/p>
&lt;p>These two positions require drastically different ways of thinking in order to solve them, yet a single good neural network (or human player) can easily find the winning sequence in each. This is because of &amp;ldquo;threads&amp;rdquo; binding all of chess: The board is always 8x8, the pieces will always move the same way, the win/lose/draw conditions are the same. These threads, borders that define what is possible in the game, are the reason why strong neural networks can exist for &amp;ldquo;generalized chess&amp;rdquo;, or any chess position.&lt;/p>
&lt;h2 id="neural-network-math-operations">Neural Network Math Operations&lt;/h2>
&lt;p>This was just a fun idea I had. I don&amp;rsquo;t know how useful it is in practice.&lt;/p>
&lt;p>Let&amp;rsquo;s say you have a network trained on recognizing a specific pattern. Given this network, can you use a specific algorithm to produce a network that recognizes the &lt;em>same pattern&lt;/em>, with less nodes (smaller layers, less powerful)? How about more nodes?&lt;/p>
&lt;p>What other operations can you do with a network? Inverting it is funny, but I&amp;rsquo;m sure that other possible operations exist.&lt;/p>
&lt;p>&lt;img src="img3_network_operations.png" alt="Image showing different hypothetical ways to modify neural networks">&lt;/p>
&lt;h2 id="know-your-enemy">Know Your Enemy&lt;/h2>
&lt;p>Generalization is one thing, but there&amp;rsquo;s more to a player than how good they are. Each person (and non-person) has their own unique fighting style based on the way they understand the game. Playing against them involves analyzing their strengths and weaknesses to come up with the best strategy. Do you push the red button, or the green button?&lt;/p>
&lt;p>The concept of being &amp;ldquo;good&amp;rdquo; at a competitive game is all relative to an extent, because the trials you put your opponents through are judged from a human perspective. For example, computers react to everything much faster than humans, so in fighting games they&amp;rsquo;re impervious to aggressive strategies, even though those same strategies perform well against humans. &lt;a href="https://www.youtube.com/watch?v=o1bfQWy8o08">(Example)&lt;/a> Thus, an aggressive fighting game player in a world of bots is suddenly really bad.&lt;/p>
&lt;p>Different playstyles are an incredibly interesting topic, and I find it odd that they aren&amp;rsquo;t brought up often when it comes to neural networks and other artificial players (besides passing observations like &amp;ldquo;wow the computer likes to play like this&amp;rdquo;). I&amp;rsquo;m interested in looking further into some questions regarding them:&lt;/p>
&lt;ul>
&lt;li>Can playstyles be represented in terms of data? Would this data look like values or like a logic system?&lt;/li>
&lt;li>If so, how can said data be made comprehensible to humans? What can neural networks do with it?&lt;/li>
&lt;li>What can be interpreted as a &amp;lsquo;playstyle&amp;rsquo;? Images? Sentences? Entities?&lt;/li>
&lt;li>Can we do fun pseudoscience and reinvent the MBTI personality test to statistically prove that I&amp;rsquo;m the only cool player in a world of crayon-eating lame losers?&lt;/li>
&lt;/ul>
&lt;h2 id="looking-ahead">Looking Ahead&lt;/h2>
&lt;ul>
&lt;li>I will be going forward because I don&amp;rsquo;t really know where else I can go.&lt;/li>
&lt;li>For Spiral I had a relatively coherent goal pretty early on, but for this project I don&amp;rsquo;t feel comfortable enough in the space of neural networks to set a clear stopping point. So I&amp;rsquo;m hoping a goal will materialize as I gain more experience and try out some of my funny ideas.&lt;/li>
&lt;li>I don&amp;rsquo;t set schedules cause things just kinda happen and if I feel bad about myself all of this comes crashing down. Being irresponsible is self-care, actually.&lt;/li>
&lt;/ul></content></item><item><title>Spiral</title><link>https://erin-online.github.io/projects/spiral/</link><pubDate>Thu, 19 May 2022 00:00:00 +0000</pubDate><guid>https://erin-online.github.io/projects/spiral/</guid><description>Project Details In this project, I created an algorithm to play weighted rock-paper-scissors. &amp;ldquo;Weighted&amp;rdquo; here means that depending on which choice you win with, you get different rewards. For example with weights [3, 2, 1], you get 3 points for winning with rock, 2 points for winning with paper, and 1 point for winning with scissors.
I wanted the algorithm to converge toward optimal (least exploitable) play. In unweighted rock-paper-scissors, this looks like a 1/3 chance to play each choice.</description><content>&lt;h2 id="project-details">Project Details&lt;/h2>
&lt;p>In this project, I created an algorithm to play weighted &lt;a href="https://en.wikipedia.org/wiki/Rock_paper_scissors">rock-paper-scissors&lt;/a>. &amp;ldquo;Weighted&amp;rdquo; here means that depending on which choice you win with, you get different rewards. For example with weights [3, 2, 1], you get 3 points for winning with rock, 2 points for winning with paper, and 1 point for winning with scissors.&lt;/p>
&lt;p>I wanted the algorithm to converge toward &lt;strong>optimal&lt;/strong> (least exploitable) play. In unweighted rock-paper-scissors, this looks like a 1/3 chance to play each choice. When you add in weights, it looks like the following:&lt;/p>
&lt;p>&lt;img src="img0_weighted_rps_explanation.png" alt="image">&lt;/p>
&lt;p>The easiest way to do this is to have the algorithm play itself 3 times to determine the weights, then set itself to the optimal strategy instantly. I thought this was a little cheap and wouldn&amp;rsquo;t make me learn much, so I looked at what else I could come up with.&lt;/p>
&lt;p>I didn&amp;rsquo;t want to use a neural network for this because it looked like an overcomplicated solution to a simple problem. I wanted to work with something I could understand.&lt;/p>
&lt;h2 id="initial-algorithm">Initial Algorithm&lt;/h2>
&lt;p>The algorithm I worked with was extremely simple, and worked similarly to the &lt;a href="https://en.wikipedia.org/wiki/Matchbox_Educable_Noughts_and_Crosses_Engine">MENACE&lt;/a>. It stored three values, one for each choice, and increased or decreased them whenever it played against itself.&lt;/p>
&lt;p>&lt;img src="img1_initial_algo_explanation.png" alt="image">&lt;/p>
&lt;p>The bulk of my tests consisted of starting all the algorithm&amp;rsquo;s values as equal, such as (100, 100, 100), then giving it an asymmetrical weight set such as [2, 1, 1] and seeing if it could find its way to the optimal strategy.&lt;/p>
&lt;p>I expected this to be fairly straightforward, but ran into confounding results. Rather than converge, each value continued to oscillate similar to a sine wave. Additionally, over time the oscillations became broader.&lt;/p>
&lt;p>&lt;img src="img2_initial_behavior.png" alt="image">&lt;/p>
&lt;p>This eventually led to &lt;em>extinction&lt;/em>, which is where one option hits 0 and so is never played again, leaving the option it beats to dominate.&lt;/p>
&lt;p>&lt;img src="img3_extinction_example.png" alt="image">&lt;/p>
&lt;h2 id="smooth-rps">Smooth RPS&lt;/h2>
&lt;p>In order to figure out what was going on here, I decided to analyze the sine-like function that the algorithm was producing and see if I could figure out its equation. This was a terrible idea, but it sounded good at the time.&lt;/p>
&lt;p>Anyway, the first thing I needed to do was get rid of the randomness involved in option selection, so I came up with Smooth RPS. Basically, rather than simulating an actual game of rock-paper-scissors, Smooth RPS predicts how much the algorithm will change, on average, and makes that change. Here&amp;rsquo;s an example:&lt;/p>
&lt;p>&lt;img src="img4_smooth_rps.png" alt="image">&lt;/p>
&lt;p>This also helpfully eliminated extinction, because the lower a choice&amp;rsquo;s value got, the less likely it was to be played, meaning the value didn&amp;rsquo;t decrease by as much.&lt;/p>
&lt;h2 id="mathematical-function-hell">Mathematical Function Hell&lt;/h2>
&lt;p>Here was the function Smooth RPS gave me for each choice:&lt;/p>
&lt;p>&lt;img src="img5_f_demonstration.png" alt="image">&lt;/p>
&lt;p>This is a little bit different from a sine wave:&lt;/p>
&lt;p>&lt;img src="img6_f_vs_sine.png" alt="image">&lt;/p>
&lt;p>By scouring Wikipedia, I found the &lt;a href="https://en.wikipedia.org/wiki/Clausen_function">Clausen function&lt;/a>, which is a really cool function involving summation of sines. There are a lot of ways to mess with it, and I spent several hours on it but was ultimately unable to have it line up with the line my algorithm produced.&lt;/p>
&lt;p>At this point, I was feeling pretty discouraged. My adventure through weird math stuff was fun, but I had no idea how to actually make progress in the project. But it wasn&amp;rsquo;t over yet.&lt;/p>
&lt;h2 id="spiral">Spiral&lt;/h2>
&lt;p>My next idea was representing the data on a &lt;a href="https://en.wikipedia.org/wiki/Barycentric_coordinate_system">barycentric graph&lt;/a>. Up until this point, I&amp;rsquo;d been convinced that I couldn&amp;rsquo;t model all three variables at once without using a 3D graph. Putting them on a triangle changed that.&lt;/p>
&lt;p>&lt;img src="img7_barycentric.png" alt="image">&lt;/p>
&lt;p>When I modeled the adaptation of the algorithm on it, I was face-to-face with the spiral for the first time:&lt;/p>
&lt;p>&lt;img src="img8_spiral_out.png" alt="image">&lt;/p>
&lt;p>(Note: The white square in the middle is the optimal strategy.)&lt;/p>
&lt;p>Suddenly everything became clear.&lt;/p>
&lt;p>The algorithm trended towards a circular pattern because it was trying to win against itself more. Optimal strategies are of little use when they can never give you any advantage. If your friend is always playing rock against you, then you should start playing paper more frequently, even though that loses to someone who plays scissors.&lt;/p>
&lt;p>Why, then, did it spiral out of control? This was due to Smooth RPS not being smooth enough. By changing the algorithm a bit at a time through iterations, it essentially tried to simulate a circle using straight lines, which resulted in it growing larger over time:&lt;/p>
&lt;p>&lt;img src="img9_tangent.png" alt="image">&lt;/p>
&lt;p>The solution was also clear. The spiral was constantly moving &lt;em>away&lt;/em> from the optimal strategy, but I could simply re-engineer it to turn it &lt;em>inward&lt;/em> instead.&lt;/p>
&lt;p>What I did for this was take every algorithm change, convert it into barycentric coordinates, rotate it counterclockwise by 90 degrees, then convert it back into value changes.&lt;/p>
&lt;p>&lt;img src="img10_spiral_algo.png" alt="image">&lt;/p>
&lt;p>This worked exceedingly well. You can see the algorithm instantly seeking out the optimal strategy.&lt;/p>
&lt;p>&lt;img src="img11_spiral.png" alt="image">&lt;/p>
&lt;h2 id="thoughts-and-takeaways">Thoughts and Takeaways&lt;/h2>
&lt;p>I&amp;rsquo;m really happy with how this project turned out. The solution was very elegant and gave me some neat things to take away.&lt;/p>
&lt;ul>
&lt;li>The concept of &amp;ldquo;breaking down&amp;rdquo; games is interesting. Fighting games for example are often considered as rock-paper-scissors + frame data and stuff, so if you have all the frame data figured out, then you can simplify the game down to rock-paper-scissors which we have here.&lt;/li>
&lt;li>Ways to visualize many variables at once can be really useful, although barycentric only works for 3 variables in 2D space.&lt;/li>
&lt;li>Machine learning algorithms should have some model of &lt;em>themselves&lt;/em>. This was implemented in the solution here when the coordinates are converted.&lt;/li>
&lt;/ul>
&lt;h2 id="plans">Plans&lt;/h2>
&lt;ul>
&lt;li>I&amp;rsquo;ll probably keep hosting this site on GitHub for now. I plan to mostly directly link it through various online avenues and don&amp;rsquo;t want to go through the time and money of setting up a domain right now.&lt;/li>
&lt;li>Obviously I&amp;rsquo;ll work on a more complicated game than rock-paper-scissors next time. I was thinking of doing something with chess, because it fits a few criteria quite nicely. It&amp;rsquo;s simple and easy to simulate, it has a lot of depth, and I have a personal interest in making sure the current best chess engine, Stockfish, perishes in spectacular fashion for telling me all my awesome and funny moves are &amp;ldquo;inaccurate&amp;rdquo; and &amp;ldquo;blunders&amp;rdquo;.&lt;/li>
&lt;li>I don&amp;rsquo;t want to use Python anymore. I know it&amp;rsquo;s often used for machine learning, but it just does not work for me. My code by the end was an absolute mess and debugging took a couple hours. I know this is partly me just being a bad programmer, but when I&amp;rsquo;ve used languages like Java in the past I feel like they do a better job forcing me to get some groundwork in place. I&amp;rsquo;ll go language shopping which will probably slow me down a bit, but this is fine, I&amp;rsquo;m in no rush.&lt;/li>
&lt;li>On that note, I&amp;rsquo;ve been meaning to try operating systems besides Windows. I&amp;rsquo;ve been on Windows machines for my whole life simply because it&amp;rsquo;s the status quo and there&amp;rsquo;s nothing new for me to wrap my head around. I think it&amp;rsquo;s time for me to actually make an effort to improve my experience using my computer. (Recommendations are welcome.)&lt;/li>
&lt;/ul></content></item><item><title/><link>https://erin-online.github.io/about/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://erin-online.github.io/about/</guid><description>hello, i&amp;rsquo;m erin! i&amp;rsquo;ve been around since 2001, 2014, or 2021, depending on who you ask. you can find me on twitter, pleroma, and discord (city#0310).
for pretty much my whole life, i&amp;rsquo;ve invested lots of my free time into various competitive games. rather than dismiss them as a waste of time, i want to use my unique perspective to make advances in artifical intelligence.
i am not currently in need of money and have no plans to turn this series of projects into anything resembling a job.</description><content>&lt;p>hello, i&amp;rsquo;m erin! i&amp;rsquo;ve been around since 2001, 2014, or 2021, depending on who you ask. you can find me on &lt;a href="https://twitter.com/cityposting">twitter&lt;/a>, &lt;a href="https://social.xenofem.me/erin">pleroma&lt;/a>, and discord (city#0310).&lt;/p>
&lt;p>for pretty much my whole life, i&amp;rsquo;ve invested lots of my free time into various competitive games. rather than dismiss them as a waste of time, i want to use my unique perspective to make advances in artifical intelligence.&lt;/p>
&lt;p>i am not currently in need of money and have no plans to turn this series of projects into anything resembling a job. however, i am generally in need of employment, so if you want to support me, contact me through one of the above avenues with remote job offers that would be a good fit for me. thanks!&lt;/p></content></item></channel></rss>